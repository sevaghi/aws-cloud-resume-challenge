import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField
} from "./chunk-REPWUYY3.js";

// node_modules/hotkeypad/dist/utils.js
function createElement(tag, props) {
  const element = document.createElement(tag);
  if (props && typeof props === "string" && props !== "")
    element.textContent = props;
  if (props && typeof props === "object")
    Object.keys(props).forEach((key) => {
      element.setAttribute(key, props[key]);
    });
  return element;
}
function createListener(element, event, callback) {
  element.addEventListener(event, callback);
}
function extractHotkeyLetter(hotkey) {
  var _a;
  const key = ((_a = hotkey.match(/\w+$/)) == null ? void 0 : _a[0]) ?? "";
  return key === "" || key.length > 1 ? "" : key.toUpperCase();
}
var VALID_META_KEYS = ["Control", "Shift", "Alt", "Meta"];
var NOT_ALLOWED_HOTKEYS = [
  "Control+T",
  "Control+Shift+T",
  "Control+W",
  "Control+Shift+W",
  "Control+N",
  "Control+Shift+N",
  "Control+Tab",
  "Control+Shift+Tab",
  "Meta+T",
  "Meta+Shift+T",
  "Meta+W",
  "Meta+Shift+W",
  "Meta+N",
  "Meta+Shift+N",
  "Meta+Tab",
  "Meta+Shift+Tab"
];
function isValidHotkey(hotkey) {
  const keys = hotkey.match(/\w+/g) ?? [];
  if (keys.length === 0)
    return false;
  const hotkeyString = keys.map((key) => {
    if (key.toUpperCase() === "CTRL")
      return "Control";
    if (key.toUpperCase() === "CMD")
      return "Meta";
    return key[0].toUpperCase() + key.slice(1).toLowerCase();
  }).join("+");
  return !NOT_ALLOWED_HOTKEYS.includes(hotkeyString) && hotkeyString.split("+").slice(0, -1).every((key) => VALID_META_KEYS.includes(key));
}

// node_modules/hotkeypad/dist/index.js
var _backdrop, _container, _commands, _closeKey, _activationKey, _activationLetter, _placeholder, _svgIconColor, _observer, _init, init_fn, _checkTagOptions, checkTagOptions_fn, _observeClassChanges, observeClassChanges_fn, _setListeners, setListeners_fn, _activateItem, activateItem_fn, _verifyCommands, verifyCommands_fn, _isOpen, isOpen_get, _sections, sections_get, _items, items_get, _iconURL, iconURL_fn, _isCustomIcon, isCustomIcon_fn, _createBackdrop, createBackdrop_fn, _createContainer, createContainer_fn, _createHeader, createHeader_fn, _createFooter, createFooter_fn, _createSections, createSections_fn, _renderCommands, renderCommands_fn;
var HotKeyPad = class {
  constructor({ closeKey, placeholder, activationLetter } = {}) {
    /* CONFIGURATION METHODS */
    __privateAdd(this, _init);
    __privateAdd(this, _checkTagOptions);
    __privateAdd(this, _observeClassChanges);
    __privateAdd(this, _setListeners);
    /* HELPER METHODS */
    /**
     * Activate the item with the corresponding hotkey
     * @param item The item to activate
     * @executes The handler of the item
     */
    __privateAdd(this, _activateItem);
    /**
     * Verify the commands array
     * @param commands The commands array to verify
     * @returns The verified commands array
     * @throws An error if the commands array is not valid
     */
    __privateAdd(this, _verifyCommands);
    /* GETTERS */
    __privateAdd(this, _isOpen);
    __privateAdd(this, _sections);
    __privateAdd(this, _items);
    /* ICON METHODS */
    __privateAdd(this, _iconURL);
    __privateAdd(this, _isCustomIcon);
    /* RENDERING METHODS */
    __privateAdd(this, _createBackdrop);
    __privateAdd(this, _createContainer);
    __privateAdd(this, _createHeader);
    __privateAdd(this, _createFooter);
    __privateAdd(this, _createSections);
    __privateAdd(this, _renderCommands);
    __publicField(this, "instance");
    __privateAdd(this, _backdrop, null);
    __privateAdd(this, _container, null);
    __privateAdd(this, _commands, []);
    __publicField(this, "currentIndex", 0);
    __privateAdd(this, _closeKey, "Escape");
    __privateAdd(this, _activationKey, void 0);
    __privateAdd(this, _activationLetter, "K");
    __privateAdd(this, _placeholder, "Search command");
    __privateAdd(this, _svgIconColor, "black");
    __privateAdd(this, _observer, new MutationObserver(__privateMethod(this, _observeClassChanges, observeClassChanges_fn).bind(this)));
    if (document.getElementById("hotkeypad") == null) {
      throw new Error("HotKeyPad instance not found in the DOM");
    }
    this.instance = document.getElementById("hotkeypad");
    __privateSet(this, _activationKey, navigator.userAgent.includes("Macintosh") ? "Cmd" : "Ctrl");
    if (closeKey && closeKey !== "")
      __privateSet(this, _closeKey, closeKey);
    if (placeholder && placeholder !== "")
      __privateSet(this, _placeholder, placeholder);
    if (activationLetter && activationLetter !== "")
      __privateSet(this, _activationLetter, activationLetter);
    __privateMethod(this, _checkTagOptions, checkTagOptions_fn).call(this);
    __privateMethod(this, _init, init_fn).call(this);
    return this;
  }
  /* PUBLIC METHODS */
  open() {
    window.dispatchEvent(new CustomEvent("hotkeypad:open"));
    this.instance.style.opacity = "1";
    this.instance.style.visibility = "visible";
    this.instance.style.pointerEvents = "auto";
    setTimeout(() => __privateGet(this, _container).querySelector("input").focus(), 200);
  }
  close() {
    window.dispatchEvent(new CustomEvent("hotkeypad:close"));
    this.instance.style.opacity = "0";
    this.instance.style.visibility = "hidden";
    this.instance.style.pointerEvents = "none";
    __privateGet(this, _container).querySelector("input").value = "";
    __privateGet(this, _container).removeEventListener("keydown", () => {
    });
    __privateGet(this, _container).removeEventListener("mouseover", () => {
    });
    __privateGet(this, _container).removeEventListener("input", () => {
    });
  }
  setCommands(commands) {
    __privateSet(this, _commands, __privateMethod(this, _verifyCommands, verifyCommands_fn).call(this, commands));
    __privateMethod(this, _renderCommands, renderCommands_fn).call(this);
    __privateMethod(this, _setListeners, setListeners_fn).call(this);
  }
  get activationKey() {
    return __privateGet(this, _activationKey);
  }
};
_backdrop = new WeakMap();
_container = new WeakMap();
_commands = new WeakMap();
_closeKey = new WeakMap();
_activationKey = new WeakMap();
_activationLetter = new WeakMap();
_placeholder = new WeakMap();
_svgIconColor = new WeakMap();
_observer = new WeakMap();
_init = new WeakSet();
init_fn = function() {
  createListener(document, "keydown", (event) => {
    const keyCode = `Key${__privateGet(this, _activationLetter).toUpperCase()}`;
    if (event.code === keyCode && (event.metaKey || event.ctrlKey)) {
      event.preventDefault();
      __privateGet(this, _isOpen, isOpen_get) ? this.close() : this.open();
    }
    if (event.key.toLowerCase() === __privateGet(this, _closeKey).toLowerCase())
      this.close();
  });
  __privateGet(this, _observer).observe(this.instance, {
    attributes: true,
    attributeFilter: ["class"],
    childList: false,
    characterData: false
  });
  __privateMethod(this, _createBackdrop, createBackdrop_fn).call(this);
  __privateMethod(this, _createContainer, createContainer_fn).call(this);
  __privateMethod(this, _createHeader, createHeader_fn).call(this);
  __privateMethod(this, _createFooter, createFooter_fn).call(this);
};
_checkTagOptions = new WeakSet();
checkTagOptions_fn = function() {
  if (this.instance.hasAttribute("data-placeholder") && this.instance.getAttribute("data-placeholder") !== "") {
    __privateSet(this, _placeholder, this.instance.getAttribute("data-placeholder"));
  }
  if (this.instance.hasAttribute("data-activation-letter") && this.instance.getAttribute("data-activation-letter") !== "") {
    __privateSet(this, _activationLetter, this.instance.getAttribute("data-activation-letter").toUpperCase());
  }
  if (this.instance.hasAttribute("data-close-key") && this.instance.getAttribute("data-close-key") !== "") {
    __privateSet(this, _closeKey, this.instance.getAttribute("data-close-key").toUpperCase());
  }
};
_observeClassChanges = new WeakSet();
observeClassChanges_fn = function(event) {
  const { attributeName, target } = event[0];
  if (attributeName === "class") {
    if (target.classList.contains("dark"))
      __privateSet(this, _svgIconColor, "white");
    else
      __privateSet(this, _svgIconColor, "black");
    __privateMethod(this, _renderCommands, renderCommands_fn).call(this);
  }
};
_setListeners = new WeakSet();
setListeners_fn = function() {
  createListener(this.instance, "keydown", (event) => {
    if (event.metaKey || event.ctrlKey) {
      __privateGet(this, _commands).find(({ hotkey, handler }) => {
        const keyLetter = extractHotkeyLetter(hotkey);
        const keyCode = `Key${keyLetter}`;
        if (event.code === keyCode) {
          event.preventDefault();
          if (handler != null)
            setTimeout(() => handler(), 200);
          this.close();
        }
        return false;
      });
    }
  });
  createListener(__privateGet(this, _container), "click", (event) => {
    var _a;
    const item = event.target;
    if (item.tagName === "LI")
      __privateMethod(this, _activateItem, activateItem_fn).call(this, item);
    if (((_a = item.parentElement) == null ? void 0 : _a.tagName) === "LI")
      __privateMethod(this, _activateItem, activateItem_fn).call(this, item.parentElement);
  });
  createListener(__privateGet(this, _container), "mouseover", (event) => {
    const item = event.target;
    if (item.tagName === "LI") {
      __privateGet(this, _items, items_get).forEach((item2) => item2.removeAttribute("data-active"));
      item.setAttribute("data-active", "");
    }
  });
  createListener(__privateGet(this, _container), "keydown", (event) => {
    const items = __privateGet(this, _items, items_get);
    this.currentIndex = Array.from(items).findIndex((item) => item.hasAttribute("data-active"));
    this.currentIndex = this.currentIndex === -1 ? 0 : this.currentIndex;
    let nextIndex = 0;
    if (event.key === "Enter") {
      event.preventDefault();
      __privateMethod(this, _activateItem, activateItem_fn).call(this, items[this.currentIndex]);
      items[this.currentIndex].removeAttribute("data-active");
      this.currentIndex = 0;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      nextIndex = this.currentIndex - 1 < 0 ? items.length - 1 : this.currentIndex - 1;
    }
    if (event.key === "ArrowDown") {
      event.preventDefault();
      nextIndex = this.currentIndex + 1 > items.length - 1 ? 0 : this.currentIndex + 1;
    }
    if (event.key === "Tab") {
      event.preventDefault();
      nextIndex = this.currentIndex + 1 > items.length - 1 ? 0 : this.currentIndex + 1;
    }
    items[this.currentIndex].removeAttribute("data-active");
    items[nextIndex].setAttribute("data-active", "");
  });
  createListener(__privateGet(this, _container), "input", (event) => {
    const input = event.target;
    const value = input.value.toLowerCase();
    const sections = __privateGet(this, _container).querySelectorAll("[data-section]");
    sections.forEach((section) => {
      const list = section.querySelector("ul");
      const items = list.querySelectorAll("li");
      items.forEach((item) => {
        const title = item.querySelector("p").innerText.toLowerCase();
        if (title.includes(value))
          item.style.display = "flex";
        else
          item.style.display = "none";
      });
      const visibleItems = list.querySelectorAll("li[style='display: flex;']");
      if (visibleItems.length === 0)
        section.style.display = "none";
      else
        section.style.display = "block";
    });
  });
};
_activateItem = new WeakSet();
activateItem_fn = function(item) {
  __privateGet(this, _commands).find(({ hotkey, handler }) => {
    if (item.getAttribute("data-hotkey") === hotkey) {
      if (handler != null)
        setTimeout(() => handler(), 200);
      this.close();
    }
    return false;
  });
};
_verifyCommands = new WeakSet();
verifyCommands_fn = function(commands) {
  if (commands.length === 0)
    throw new Error("The commands array cannot be empty");
  commands.forEach((command) => {
    if (command.id === "" || command.title === "" || command.hotkey === "" || command.handler == null)
      throw new Error("The command object is not valid. It should contain an id, title, hotkey and handler");
    if (!isValidHotkey(command.hotkey))
      throw new Error("The hotkey is not valid. It should only contain CTRL, CMD, ALT, SHIFT and a letter. Also it cannot contain browser or system reserved hotkeys such as CTRL+T, CTRL+N, CTRL+W, etc.");
    if (command.icon != null && typeof command.icon !== "string")
      throw new Error("The icon should be a string");
    const keys = command.hotkey.match(/\w+/g) ?? [];
    if (keys.length > 2)
      throw new Error("The hotkey only supports 2 keys maximum");
  });
  return commands;
};
_isOpen = new WeakSet();
isOpen_get = function() {
  return this.instance.style.visibility === "visible";
};
_sections = new WeakSet();
sections_get = function() {
  const map = /* @__PURE__ */ new Map();
  __privateGet(this, _commands).forEach((item) => {
    const key = typeof item.section !== "string" || item.section === "" ? "Unlisted" : item.section;
    const { section, ...content } = item;
    const collection = map.get(key);
    if (!collection)
      map.set(key, [content]);
    else
      collection.push(content);
  });
  return Array.from(map);
};
_items = new WeakSet();
items_get = function() {
  return __privateGet(this, _container).querySelectorAll("li");
};
_iconURL = new WeakSet();
iconURL_fn = function(icon) {
  return `https://cdn.simpleicons.org/${icon}/${__privateGet(this, _svgIconColor)}`;
};
_isCustomIcon = new WeakSet();
isCustomIcon_fn = function(icon) {
  return /<svg/.test(icon) || /<img/.test(icon) || /<i/.test(icon) || icon === "";
};
_createBackdrop = new WeakSet();
createBackdrop_fn = function() {
  __privateSet(this, _backdrop, createElement("div", {
    "data-backdrop": "",
    "aria-hidden": "true"
  }));
  createListener(__privateGet(this, _backdrop), "click", () => this.close());
  this.instance.appendChild(__privateGet(this, _backdrop));
};
_createContainer = new WeakSet();
createContainer_fn = function() {
  __privateSet(this, _container, createElement("div", { "data-container": "" }));
  this.instance.appendChild(__privateGet(this, _container));
};
_createHeader = new WeakSet();
createHeader_fn = function() {
  const headerEl = createElement("header");
  const inputEl = createElement("input", {
    type: "text",
    placeholder: __privateGet(this, _placeholder),
    "aria-label": __privateGet(this, _placeholder),
    autocomplete: "off",
    spellcheck: "false"
  });
  headerEl.appendChild(inputEl);
  __privateGet(this, _container).appendChild(headerEl);
};
_createFooter = new WeakSet();
createFooter_fn = function() {
  const footerEl = createElement("footer");
  const keyEnter = createElement("kbd", "↩");
  const keyUp = createElement("kbd", "↑");
  const keyDown = createElement("kbd", "↓");
  const keyEsc = createElement("kbd", __privateGet(this, _closeKey));
  const keyCmdK = createElement("kbd", `${__privateGet(this, _activationKey)} + ${__privateGet(this, _activationLetter)}`);
  const pEnter = createElement("p", " to select");
  const pUpDown = createElement("p", " to navigate");
  const pCmdK = createElement("p", " to close");
  pEnter.prepend(keyEnter);
  pUpDown.prepend(keyUp, keyDown);
  pCmdK.prepend(keyCmdK, keyEsc);
  footerEl.append(pEnter, pUpDown, pCmdK);
  __privateGet(this, _container).appendChild(footerEl);
};
_createSections = new WeakSet();
createSections_fn = function() {
  const sectionsEl = createElement("div");
  sectionsEl.setAttribute("data-sections", "");
  __privateGet(this, _sections, sections_get).forEach(([section, commands]) => {
    const sectionEl = createElement("div");
    sectionEl.setAttribute("data-section", section.toLowerCase());
    if (section !== "Unlisted") {
      const titleEl = createElement("h4", section);
      sectionEl.appendChild(titleEl);
    }
    const listEl = createElement("ul");
    commands.forEach(({ title, icon, hotkey }) => {
      const keys = hotkey.split("+").map((key) => key.trim());
      if (icon == null)
        icon = "";
      const stringIcon = __privateMethod(this, _isCustomIcon, isCustomIcon_fn).call(this, icon) ? icon : `<img src="${__privateMethod(this, _iconURL, iconURL_fn).call(this, icon)}" alt="${title}" />`;
      const itemEl = createElement("li");
      itemEl.setAttribute("data-hotkey", hotkey);
      itemEl.setAttribute("tabindex", "0");
      if (stringIcon !== "") {
        const itemIcon = createElement("span");
        itemIcon.innerHTML = stringIcon;
        itemEl.appendChild(itemIcon);
      }
      const itemTitle = createElement("p");
      itemTitle.append(title);
      const itemKeys = createElement("div");
      keys.forEach((key) => {
        const keyEl = createElement("span", key);
        itemKeys.appendChild(keyEl);
      });
      itemEl.appendChild(itemTitle);
      itemEl.appendChild(itemKeys);
      listEl.appendChild(itemEl);
    });
    sectionEl.appendChild(listEl);
    sectionsEl.appendChild(sectionEl);
  });
  __privateGet(this, _container).insertBefore(sectionsEl, __privateGet(this, _container).lastChild);
};
_renderCommands = new WeakSet();
renderCommands_fn = function() {
  const sectionsEl = __privateGet(this, _container).querySelector("[data-sections]");
  if (sectionsEl)
    sectionsEl.remove();
  __privateMethod(this, _createSections, createSections_fn).call(this);
  __privateGet(this, _items, items_get)[0].setAttribute("data-active", "");
};
export {
  HotKeyPad as default
};
//# sourceMappingURL=hotkeypad.js.map
